
  services:
    db:
      image: postgres:15
      container_name: db
      restart: unless-stopped
      environment:
        POSTGRES_USER: ${POSTGRES_USER}
        POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
        POSTGRES_DB: ${POSTGRES_DB:-postgres}
        # application DB vars are also passed for external apps to create/consume
        APP_DB: ${APP_DB}
        APP_DB_USER: ${APP_DB_USER}
        APP_DB_PASSWORD: ${APP_DB_PASSWORD}
      volumes:
        - db-data:/var/lib/postgresql/data
        - ./db/init:/docker-entrypoint-initdb.d:ro
      healthcheck:
        test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} -q || exit 1"]
        interval: 10s
        timeout: 5s
        retries: 12
        start_period: 30s
      ports:
        - "5432:5432"

    vault:
      build:
        context: ./vault
        dockerfile: Dockerfile
      image: vault-local:1.21.1
      container_name: vault
      restart: unless-stopped
      cap_add:
        - IPC_LOCK
      environment:
        # VAULT_ADDR is used by the vault CLI inside the container. 0.0.0.0 is not a routable client address.
        # Use 127.0.0.1 so healthchecks and docker exec CLI calls can talk to the local daemon.
        VAULT_ADDR: "http://127.0.0.1:8200"
        VAULT_LOG_LEVEL: ${VAULT_LOG_LEVEL:-info}
      volumes:
        - vault-data:/vault/data
        - ./vault/vault.hcl.tpl:/vault/config/vault.hcl.tpl:ro
        - ./vault/docker-entrypoint.sh:/usr/local/bin/vault-docker-entrypoint.sh:ro
        - ./vault/init:/vault/init        # SHARE: init artifacts written here
      ports:
        - "8200:8200"
      healthcheck:
        # Explicitly set VAULT_ADDR for the CLI in healthcheck to avoid relying on container env
        test: ["CMD-SHELL", "VAULT_ADDR=http://127.0.0.1:8200 vault status -format=json >/dev/null 2>&1"]
        interval: 5s
        timeout: 5s
        retries: 8
        start_period: 20s

    keycloak:
      build:
        context: ./keycloak
        dockerfile: Dockerfile
      container_name: keycloak
      restart: unless-stopped
      environment:
        KC_HTTP_ENABLED: "true"
        KC_HOSTNAME: "0.0.0.0"
        KC_HOSTNAME_STRICT: "false"
        KC_HOSTNAME_STRICT_HTTPS: "false"
        KC_PROXY: "edge"
        KC_BOOTSTRAP_ADMIN_USERNAME: ${KEYCLOAK_ADMIN_USER}
        KC_BOOTSTRAP_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}
#        KEYCLOAK_IMPORT: /opt/keycloak/data/import/statement-service-realm.json
      command: ["start-dev", "--import-realm"]
      volumes:
        - keycloak-data:/opt/keycloak/data
        - ./keycloak/realms:/opt/keycloak/data/import:ro
      ports:
        - "8081:8080"
      healthcheck:
        test: ["CMD-SHELL", "curl -fsS http://localhost:8080/health || exit 1"]
        interval: 10s
        timeout: 5s
        retries: 6
        start_period: 30s

    config-server:
      build:
        context: ..
        dockerfile: config-server/docker/Dockerfile
      image: config-server:latest
      environment:
        - VAULT_ADDR=http://vault:8200
        - APPROLE_ROLE_ID_FILE=/vault/init/approle-role-id
        - APPROLE_SECRET_ID_FILE=/vault/init/approle-secret-id
      volumes:
        - ./vault/init:/vault/init:ro
        # Mount the local config repository so the Config Server's native backend can read files
        - ./config-repo:/config-repo:ro
      depends_on:
        vault:
          condition: service_healthy
      ports:
        - "8888:8888"
      healthcheck:
        test: ["CMD-SHELL", "curl -fsS http://localhost:8888/actuator/health || exit 1"]
        interval: 10s
        timeout: 5s
        retries: 6
        start_period: 30s



  volumes:
    db-data:
    vault-data:
    keycloak-data:
